<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 4. Using PostGIS: Data Management and Queries</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="PostGIS 1.4 Manual"><link rel="up" href="index.html" title="PostGIS 1.4 Manual"><link rel="prev" href="ch03.html" title="Chapter 3. Frequently Asked Questions"><link rel="next" href="ch05.html" title="Chapter 5. Using PostGIS: Building Applications"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Using PostGIS: Data Management and Queries</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch05.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter 4. Using PostGIS: Data Management and Queries"><div class="titlepage"><div><div><h2 class="title"><a name="id418262"></a>Chapter 4. Using PostGIS: Data Management and Queries</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch04.html#RefObject">4.1. GIS Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id417971">4.1.1. OpenGIS WKB and WKT</a></span></dt><dt><span class="sect2"><a href="ch04.html#id418353">4.1.2. PostGIS EWKB, EWKT and Canonical Forms</a></span></dt><dt><span class="sect2"><a href="ch04.html#id418484">4.1.3. SQL-MM Part 3</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id418599">4.2. Using OpenGIS Standards</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#spatial_ref_sys">4.2.1. The SPATIAL_REF_SYS Table and Spatial Reference Systems</a></span></dt><dt><span class="sect2"><a href="ch04.html#id418870">4.2.2. The GEOMETRY_COLUMNS Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#Create_Spatial_Table">4.2.3. Creating a Spatial Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#Manual_Register_Spatial_Column">4.2.4. Manually Registering Geometry Columns in geometry_columns</a></span></dt><dt><span class="sect2"><a href="ch04.html#OGC_Validity">4.2.5. Ensuring OpenGIS compliancy of geometries</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id419979">4.3. Loading GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id419990">4.3.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420038">4.3.2. Using the Loader</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id420244">4.4. Retrieving GIS Data</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id420255">4.4.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420379">4.4.2. Using the Dumper</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id420538">4.5. Building Indexes</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id420580">4.5.1. GiST Indexes</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420631">4.5.2. Using Indexes</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch04.html#id420725">4.6. Complex Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch04.html#id420739">4.6.1. Taking Advantage of Indexes</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420816">4.6.2. Examples of Spatial SQL</a></span></dt></dl></dd></dl></div><div class="sect1" title="4.1. GIS Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RefObject"></a>4.1. GIS Objects</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="ch04.html#id417971">4.1.1. OpenGIS WKB and WKT</a></span></dt><dt><span class="sect2"><a href="ch04.html#id418353">4.1.2. PostGIS EWKB, EWKT and Canonical Forms</a></span></dt><dt><span class="sect2"><a href="ch04.html#id418484">4.1.3. SQL-MM Part 3</a></span></dt></dl></div><p>The GIS objects supported by PostGIS are a superset of the "Simple
    Features" defined by the OpenGIS Consortium (OGC). As of version 0.9,
    PostGIS supports all the objects and functions specified in the OGC
    "Simple Features for SQL" specification.</p><p>PostGIS extends the standard with support for 3DZ,3DM and 4D
    coordinates.</p><div class="sect2" title="4.1.1. OpenGIS WKB and WKT"><div class="titlepage"><div><div><h3 class="title"><a name="id417971"></a>4.1.1. OpenGIS WKB and WKT</h3></div></div></div><p>The OpenGIS specification defines two standard ways of expressing
      spatial objects: the Well-Known Text (WKT) form and the Well-Known
      Binary (WKB) form. Both WKT and WKB include information about the type
      of the object and the coordinates which form the object.</p><p>Examples of the text representations (WKT) of the spatial objects
      of the features are as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>POINT(0 0)</p></li><li class="listitem"><p>LINESTRING(0 0,1 1,1 2)</p></li><li class="listitem"><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li class="listitem"><p>MULTIPOINT(0 0,1 2)</p></li><li class="listitem"><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)),
          ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))</p></li></ul></div><p>The OpenGIS specification also requires that the internal storage
      format of spatial objects include a spatial referencing system
      identifier (SRID). The SRID is required when creating spatial objects
      for insertion into the database.</p><p>Input/Output of these formats are available using the following
      interfaces:</p><pre class="programlisting">bytea WKB = ST_AsBinary(geometry); 
text WKT = ST_AsText(geometry); 
geometry = ST_GeomFromWKB(bytea WKB, SRID); 
geometry = ST_GeometryFromText(text WKT, SRID);</pre><p>For example, a valid insert statement to create and insert an OGC
      spatial object would be (where 312 is the srid of our geometry):</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name )
  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');</pre></div><div class="sect2" title="4.1.2. PostGIS EWKB, EWKT and Canonical Forms"><div class="titlepage"><div><div><h3 class="title"><a name="id418353"></a>4.1.2. PostGIS EWKB, EWKT and Canonical Forms</h3></div></div></div><p>OGC formats only support 2d geometries, and the associated SRID is
      *never* embedded in the input/output representations.</p><p>PostGIS extended formats are currently superset of OGC one (every
      valid WKB/WKT is a valid EWKB/EWKT) but this might vary in the future,
      specifically if OGC comes out with a new format conflicting with our
      extensions. Thus you SHOULD NOT rely on this feature!</p><p>PostGIS EWKB/EWKT add 3dm,3dz,4d coordinates support and embedded
      SRID information.</p><p>Examples of the text representations (EWKT) of the extended
      spatial objects of the features are as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>POINT(0 0 0) -- XYZ</p></li><li class="listitem"><p>SRID=32632;POINT(0 0) -- XY with SRID</p></li><li class="listitem"><p>POINTM(0 0 0) -- XYM</p></li><li class="listitem"><p>POINT(0 0 0 0) -- XYZM</p></li><li class="listitem"><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID</p></li><li class="listitem"><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4
          1))</p></li><li class="listitem"><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2
          0,1 1 0))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2
          0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTIONM(POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4
          5))</p></li></ul></div><p>Input/Output of these formats are available using the following
      interfaces:</p><pre class="programlisting">bytea EWKB = ST_AsEWKB(geometry); 
text EWKT = ST_AsEWKT(geometry); 
geometry = ST_GeomFromEWKB(bytea EWKB); 
geometry = ST_GeomFromEWKT(text EWKT);</pre><p>For example, a valid insert statement to create and insert a
      PostGIS spatial object would be:</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name ) 
  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )</pre><p>The "canonical forms" of a PostgreSQL type are the representations
      you get with a simple query (without any function call) and the one
      which is guaranteed to be accepted with a simple insert, update or copy.
      For the postgis 'geometry' type these are: </p><pre class="programlisting">- Output 
  - binary: EWKB 
    ascii: HEXEWKB (EWKB in hex form) 
- Input 
  - binary: EWKB 
    ascii: HEXEWKB|EWKT </pre><p>For example this statement reads EWKT and returns HEXEWKB in the
      process of canonical ascii input/output:</p><pre class="programlisting">=# SELECT 'SRID=4;POINT(0 0)'::geometry;

geometry 
----------------------------------------------------
01010000200400000000000000000000000000000000000000 
(1 row)</pre></div><div class="sect2" title="4.1.3. SQL-MM Part 3"><div class="titlepage"><div><div><h3 class="title"><a name="id418484"></a>4.1.3. SQL-MM Part 3</h3></div></div></div><p>The SQL Multimedia Applications Spatial specification extends the
      simple features for SQL spec by defining a number of circularly
      interpolated curves.</p><p>The SQL-MM definitions include 3dm, 3dz and 4d coordinates, but do
      not allow the embedding of SRID information.</p><p>The well-known text extensions are not yet fully supported.
      Examples of some simple curved geometries are shown below:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>CIRCULARSTRING(0 0, 1 1, 1 0)</p><p>CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)</p><p>The CIRCULARSTRING is the basic curve type, similar to a 
          LINESTRING in the linear world.  A single segment required three 
          points, the start and end points (first and third) and any other 
          point on the arc.  The exception to this is for a closed circle, 
          where the start and end points are the same.  In this case the 
          second point MUST be the center of the arc, ie the opposite side of 
          the circle.  To chain arcs together, the last point of the previous 
          arc becomes the first point of the next arc, just like in 
          LINESTRING.  This means that a valid circular string must have an 
          odd number of points greated than 1.</p></li><li class="listitem"><p>COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))</p><p>A compound curve is a single, continuous curve that has both 
          curved (circular) segments and linear segments.  That means that 
          in addition to having well-formed components, the end point of 
          every component (except the last) must be coincident with the 
          start point of the following component.</p></li><li class="listitem"><p>CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3
          3, 3 1, 1 1))</p><p>Example compound curve in a curve polygon:  
		  		CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), 
					CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )
		  </p><p>A CURVEPOLYGON is just like a polygon, with an outer ring 
          and zero or more inner rings.  The difference is that a ring can 
          take the form of a circular string, linear string or compound 
          string.</p><p>As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon.</p></li><li class="listitem"><p>MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))</p><p>The MULTICURVE is a collection of curves, which can include 
          linear strings, circular strings or compound strings.</p></li><li class="listitem"><p>MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0
          0),(1 1, 3 3, 3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5
          11, 11 11.5, 11 11)))</p><p>This is a collection of surfaces, which can be (linear) 
          polygons or curve polygons.</p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>PostGIS prior to 1.4 does not support compound curves in a curve polygon, but
				PostGIS 1.4 and above do support the use of Compound Curves in
        a Curve Polygon.</p></td></tr></table></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>All floating point comparisons within the SQL-MM implementation
        are performed to a specified tolerance, currently 1E-8.</p></td></tr></table></div></div></div><div class="sect1" title="4.2. Using OpenGIS Standards"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id418599"></a>4.2. Using OpenGIS Standards</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="ch04.html#spatial_ref_sys">4.2.1. The SPATIAL_REF_SYS Table and Spatial Reference Systems</a></span></dt><dt><span class="sect2"><a href="ch04.html#id418870">4.2.2. The GEOMETRY_COLUMNS Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#Create_Spatial_Table">4.2.3. Creating a Spatial Table</a></span></dt><dt><span class="sect2"><a href="ch04.html#Manual_Register_Spatial_Column">4.2.4. Manually Registering Geometry Columns in geometry_columns</a></span></dt><dt><span class="sect2"><a href="ch04.html#OGC_Validity">4.2.5. Ensuring OpenGIS compliancy of geometries</a></span></dt></dl></div><p>The OpenGIS "Simple Features Specification for SQL" defines standard
    GIS object types, the functions required to manipulate them, and a set of
    meta-data tables. In order to ensure that meta-data remain consistent,
    operations such as creating and removing a spatial column are carried out
    through special procedures defined by OpenGIS.</p><p>There are two OpenGIS meta-data tables:
    <code class="varname">SPATIAL_REF_SYS</code> and
    <code class="varname">GEOMETRY_COLUMNS</code>. The
    <code class="varname">SPATIAL_REF_SYS</code> table holds the numeric IDs and textual
    descriptions of coordinate systems used in the spatial database.</p><div class="sect2" title="4.2.1. The SPATIAL_REF_SYS Table and Spatial Reference Systems"><div class="titlepage"><div><div><h3 class="title"><a name="spatial_ref_sys"></a>4.2.1. The SPATIAL_REF_SYS Table and Spatial Reference Systems</h3></div></div></div><p>The spatial_ref_sys table is a PostGIS included and OGC compliant database table that lists over 3000
	  		known <a class="ulink" href="http://www.sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-datums2c-ellipsoids-e28093-confusing.aspx" target="_top">spatial reference systems</a> 
			and details needed to transform/reproject between them.</p><p>Although the PostGIS spatial_ref_sys table contains over 3000 of the more commonly used spatial reference system definitions that can be handled by the proj library, it does not contain all known to man and
	  		you can even define your own custom projection if you are familiar with proj4 constructs.  Keep in mind that most spatial reference systems are regional and have no meaning when used outside of the bounds they were intended for.</p><p>An excellent resource for finding spatial reference systems not defined in the core set is <a class="ulink" href="http://spatialreference.org/" target="_top">http://spatialreference.org/</a></p><p>Some of the more commonly used spatial reference systems are: <a class="ulink" href="http://spatialreference.org/ref/epsg/4326/" target="_top">4326 - WGS 84 Long Lat</a>, 
	  		<a class="ulink" href="http://spatialreference.org/ref/epsg/4269/" target="_top">4269 - NAD 83 Long Lat</a>, 
			<a class="ulink" href="http://spatialreference.org/ref/epsg/3395/" target="_top">3395 - WGS 84 World Mercator</a>,
			<a class="ulink" href="http://spatialreference.org/ref/epsg/2163/" target="_top">2163 - US National Atlas Equal Area</a>,
			Spatial reference systems for each NAD 83, WGS 84 UTM zone - UTM zones are one of the most ideal for measurement, but only cover 6-degree regions.
	</p><p>
		Various US state plane spatial reference systems (meter or feet based) - usually one or 2 exists per US state.  Most of the meter ones are in the core set, but many of the 
		feet based ones or ESRI created ones you will need to pull from <a class="ulink" href="http://spatialreference.org" target="_top">spatialreference.org</a>.
	</p><p>
		For details on determining which UTM zone to use for your area of interest, check out the <a class="ulink" href="http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance" target="_top">utmzone PostGIS plpgsql helper function</a>.
	</p><p>The <code class="varname">SPATIAL_REF_SYS</code> table definition is as
      follows:</p><pre class="programlisting">CREATE TABLE spatial_ref_sys ( 
  srid       INTEGER NOT NULL PRIMARY KEY, 
  auth_name  VARCHAR(256), 
  auth_srid  INTEGER, 
  srtext     VARCHAR(2048), 
  proj4text  VARCHAR(2048) 
)</pre><p>The <code class="varname">SPATIAL_REF_SYS</code> columns are as
      follows:</p><div class="variablelist"><dl><dt><span class="term"><a class="ulink" href="http://en.wikipedia.org/wiki/SRID" target="_top">SRID</a></span></dt><dd><p>An integer value that uniquely identifies the Spatial
            Referencing System (SRS) within the database.</p></dd><dt><span class="term">AUTH_NAME</span></dt><dd><p>The name of the standard or standards body that is being
            cited for this reference system. For example, "EPSG" would be a
            valid <code class="varname">AUTH_NAME</code>.</p></dd><dt><span class="term">AUTH_SRID</span></dt><dd><p>The ID of the Spatial Reference System as defined by the
            Authority cited in the <code class="varname">AUTH_NAME</code>. In the case
            of EPSG, this is where the EPSG projection code would go.</p></dd><dt><span class="term">SRTEXT</span></dt><dd><p>The Well-Known Text representation of the Spatial Reference
            System. An example of a WKT SRS representation is:</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N",
  GEOGCS["NAD83",
    DATUM["North_American_Datum_1983", 
      SPHEROID["GRS 1980",6378137,298.257222101] 
    ],
    PRIMEM["Greenwich",0],
    UNIT["degree",0.0174532925199433] 
  ],
  PROJECTION["Transverse_Mercator"],
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123],
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000],
  PARAMETER["false_northing",0], 
  UNIT["metre",1] 
]</pre><p>For a listing of EPSG projection codes and their
            corresponding WKT representations, see <a class="ulink" href="http://www.opengeospatial.org/" target="_top">http://www.opengeospatial.org/</a>.
            For a discussion of WKT in general, see the OpenGIS "Coordinate
            Transformation Services Implementation Specification" at <a class="ulink" href="http://www.opengeospatial.org/standards" target="_top">http://www.opengeospatial.org/standards</a>.
            For information on the European Petroleum Survey Group (EPSG) and
            their database of spatial reference systems, see <a class="ulink" href="http://www.epsg.org/" target="_top">http://www.epsg.org</a>.</p></dd><dt><span class="term">PROJ4TEXT</span></dt><dd><p>PostGIS uses the Proj4 library to provide coordinate
            transformation capabilities. The <code class="varname">PROJ4TEXT</code>
            column contains the Proj4 coordinate definition string for a
            particular SRID. For example:</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>For more information about, see the Proj4 web site at <a class="ulink" href="http://trac.osgeo.org/proj/" target="_top">http://trac.osgeo.org/proj/</a>.
            The <code class="filename">spatial_ref_sys.sql</code> file contains both
            <code class="varname">SRTEXT</code> and <code class="varname">PROJ4TEXT</code>
            definitions for all EPSG projections.</p></dd></dl></div></div><div class="sect2" title="4.2.2. The GEOMETRY_COLUMNS Table"><div class="titlepage"><div><div><h3 class="title"><a name="id418870"></a>4.2.2. The GEOMETRY_COLUMNS Table</h3></div></div></div><p>The <code class="varname">GEOMETRY_COLUMNS</code> table definition is as
      follows:</p><pre class="programlisting">CREATE TABLE geometry_columns ( 
  f_table_catalog    VARRCHAR(256) NOT NULL, 
  f_table_schema     VARCHAR(256) NOT NULL,
  f_table_nam        VARCHAR(256) NOT NULL, 
  f_geometry_column  VARCHAR(256) NOT NULL, 
  coord_dimension    INTEGER NOT NULL, 
  srid               INTEGER NOT NULL, 
  type               VARCHAR(30) NOT NULL 
)</pre><p>The columns are as follows:</p><div class="variablelist"><dl><dt><span class="term">F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME</span></dt><dd><p>The fully qualified name of the feature table containing the
            geometry column. Note that the terms "catalog" and "schema" are
            Oracle-ish. There is not PostgreSQL analogue of "catalog" so that
            column is left blank -- for "schema" the PostgreSQL schema name is
            used (<code class="varname">public</code> is the default).</p></dd><dt><span class="term">F_GEOMETRY_COLUMN</span></dt><dd><p>The name of the geometry column in the feature table.</p></dd><dt><span class="term">COORD_DIMENSION</span></dt><dd><p>The spatial dimension (2, 3 or 4 dimensional) of the
            column.</p></dd><dt><span class="term">SRID</span></dt><dd><p>The ID of the spatial reference system used for the
            coordinate geometry in this table. It is a foreign key reference
            to the <code class="varname">SPATIAL_REF_SYS</code>.</p></dd><dt><span class="term">TYPE</span></dt><dd><p>The type of the spatial object. To restrict the spatial
            column to a single type, use one of: POINT, LINESTRING, POLYGON,
            MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION or
            corresponding XYM versions POINTM, LINESTRINGM, POLYGONM,
            MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, GEOMETRYCOLLECTIONM.
            For heterogeneous (mixed-type) collections, you can use "GEOMETRY"
            as the type.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This attribute is (probably) not part of the OpenGIS
              specification, but is required for ensuring type
              homogeneity.</p></td></tr></table></div></dd></dl></div></div><div class="sect2" title="4.2.3. Creating a Spatial Table"><div class="titlepage"><div><div><h3 class="title"><a name="Create_Spatial_Table"></a>4.2.3. Creating a Spatial Table</h3></div></div></div><p>Creating a table with spatial data is done in two stages:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Create a normal non-spatial table.</p><p>For example: <span class="command"><strong>CREATE TABLE ROADS_GEOM ( ID int4, NAME
          varchar(25) )</strong></span></p></li><li class="listitem"><p>Add a spatial column to the table using the OpenGIS
          "AddGeometryColumn" function.</p><p>The syntax is: </p><pre class="programlisting">AddGeometryColumn(
  &lt;schema_name&gt;,
  &lt;table_name&gt;, 
  &lt;column_name&gt;, 
  &lt;srid&gt;,
  &lt;type&gt;, 
  &lt;dimension&gt;
)</pre><p> Or, using current schema: </p><pre class="programlisting">AddGeometryColumn(
  &lt;table_name&gt;,
  &lt;column_name&gt;, 
  &lt;srid&gt;, 
  &lt;type&gt;,
  &lt;dimension&gt;
)</pre><p>Example1: <span class="command"><strong>SELECT AddGeometryColumn('public',
          'roads_geom', 'geom', 423, 'LINESTRING', 2)</strong></span></p><p>Example2: <span class="command"><strong>SELECT AddGeometryColumn( 'roads_geom',
          'geom', 423, 'LINESTRING', 2)</strong></span></p></li></ul></div><p>Here is an example of SQL used to create a table and add a spatial
      column (assuming that an SRID of 128 exists already):</p><pre class="programlisting">CREATE TABLE parks ( 
  park_id    INTEGER, 
  park_name  VARCHAR,
  park_date  DATE,
  park_type  VARCHAR
);
SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );</pre><p>Here is another example, using the generic "geometry" type and the
      undefined SRID value of -1:</p><pre class="programlisting">CREATE TABLE roads ( 
  road_id INTEGER,
  road_name VARCHAR
);
SELECT AddGeometryColumn( 'roads', 'roads_geom', -1, 'GEOMETRY', 3 );</pre></div><div class="sect2" title="4.2.4. Manually Registering Geometry Columns in geometry_columns"><div class="titlepage"><div><div><h3 class="title"><a name="Manual_Register_Spatial_Column"></a>4.2.4. Manually Registering Geometry Columns in geometry_columns</h3></div></div></div><p>The AddGeometryColumn() approach creates a geometry column and also registers the new
		column in the geometry_columns table.  If your software utilizes geometry_columns, then 
		any geometry columns you need to query by must be registered in this table.  Two of the cases
		where you want a geometry column to be registered in the geometry_columns table, but you can't use 
		AddGeometryColumn, is in the case of SQL Views and bulk inserts.  For these cases, you must register the column in the 
		geometry_columns table manually.  Below is a simple script to do that.</p><pre class="programlisting">
--Lets say you have a view created like this
CREATE VIEW  public.vwmytablemercator AS
	SELECT gid, ST_Transform(the_geom,3395) As the_geom, f_name
	FROM public.mytable;
	
--To register this table in AddGeometry columns - do the following
INSERT INTO geometry_columns(f_table_catalog, f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, "type")
SELECT '', 'public', 'vwmytablemercator', 'the_geom', ST_CoordDim(the_geom), ST_SRID(the_geom), GeometryType(the_geom)
FROM public.vwmytablemercator LIMIT 1;

		</pre><pre class="programlisting">
--Lets say you created a derivative table by doing a bulk insert
SELECT poi.gid, poi.the_geom, citybounds.city_name
INTO myschema.myspecialpois
FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.the_geom, poi.the_geom);

--Create index on new table
CREATE INDEX idx_myschema_myspecialpois_geom_gist
  ON myschema.myspecialpois USING gist(the_geom);

--To manually register this new table's geometry column in geometry_columns 
-- we do the same thing as with view 
INSERT INTO geometry_columns(f_table_catalog, f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, "type")
SELECT '', 'myschema', 'myspecialpois', 'the_geom', ST_CoordDim(the_geom), ST_SRID(the_geom), GeometryType(the_geom)
FROM public.myschema.myspecialpois LIMIT 1;

		</pre></div><div class="sect2" title="4.2.5. Ensuring OpenGIS compliancy of geometries"><div class="titlepage"><div><div><h3 class="title"><a name="OGC_Validity"></a>4.2.5. Ensuring OpenGIS compliancy of geometries</h3></div></div></div><p>PostGIS is compliant with the Open Geospatial Consortium&#8217;s (OGC) 
      OpenGIS Specifications.  As such, many PostGIS methods require, or more 
      accurately, assume that geometries that are operated on are both simple 
      and valid. for example, it does not make sense to calculate the area of 
      a polygon that has a hole defined outside of the polygon, or to construct
      a polygon from a non-simple boundary line.</p><p>According to the OGC Specifications, a <span class="emphasis"><em>simple</em></span>
      geometry is one that has no anomalous geometric points, such as self 
      intersection or self tangency and primarily refers to 0 or 1-dimensional 
      geometries (i.e. <code class="varname">[MULTI]POINT, [MULTI]LINESTRING</code>).  
      Geometry validity, on the other hand, primarily refers to 2-dimensional 
      geometries (i.e. <code class="varname">[MULTI]POLYGON)</code> and defines the set 
      of assertions that characterizes a valid polygon. The description of each 
      geometric class includes specific conditions that further detail geometric 
      simplicity and validity.</p><p>A <code class="varname">POINT</code> is inheritably <span class="emphasis"><em>simple</em></span> 
      as a 0-dimensional geometry object.</p><p><code class="varname">MULTIPOINT</code>s are <span class="emphasis"><em>simple</em></span> if 
      no two coordinates (<code class="varname">POINT</code>s) are equal (have identical 
      coordinate values).</p><p>A <code class="varname">LINESTRING</code> is <span class="emphasis"><em>simple</em></span> if 
      it does not pass through the same <code class="varname">POINT</code> twice (except 
      for the endpoints, in which case it is referred to as a linear ring and 
      additionally considered closed).</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple01.png"><div class="caption"><p><span class="bold"><strong>(a)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple02.png"><div class="caption"><p><span class="bold"><strong>(b)</strong></span></p></div></div></div></td></tr><tr><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple03.png"><div class="caption"><p><span class="bold"><strong>(c)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple04.png"><div class="caption"><p><span class="bold"><strong>(d)</strong></span></p></div></div></div></td></tr></tbody></table><table border="1"><colgroup><col></colgroup><tbody><tr><td><p><span class="bold"><strong>(a)</strong></span> and 
          		<span class="bold"><strong>(c)</strong></span> are simple 
          		<code class="varname">LINESTRING</code>s, <span class="bold"><strong>(b)</strong></span> 
          		and <span class="bold"><strong>(d)</strong></span> are not.</p></td></tr></tbody></table></div><p>A <code class="varname">MULTILINESTRING</code> is <span class="emphasis"><em>simple</em></span> 
      only if all of its elements are simple and the only intersection between 
      any two elements occurs at <code class="varname">POINT</code>s that are on the 
      boundaries of both elements.  </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple05.png"><div class="caption"><p><span class="bold"><strong>(e)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple06.png"><div class="caption"><p><span class="bold"><strong>(f)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple07.png"><div class="caption"><p><span class="bold"><strong>(g)</strong></span></p></div></div></div></td></tr></tbody></table><table border="1"><colgroup><col></colgroup><tbody><tr><td><p><span class="bold"><strong>(e)</strong></span> and 
          		<span class="bold"><strong>(f)</strong></span> are simple 
          		<code class="varname">MULTILINESTRING</code>s, <span class="bold"><strong>(g)</strong></span> 
          		is not.</p></td></tr></tbody></table></div><p>By definition, a <code class="varname">POLYGON</code> is always 
      <span class="emphasis"><em>simple</em></span>.  It is <span class="emphasis"><em>valid</em></span> if no two 
      rings in the boundary (made up of an exterior ring and interior rings) 
      cross.  The boundary of a <code class="varname">POLYGON</code> may intersect at a 
      <code class="varname">POINT</code> but only as a tangent (i.e. not on a line).  
      A <code class="varname">POLYGON</code> may not have cut lines or spikes and the 
      interior rings must be contained entirely within the exterior ring.</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid01.png"><div class="caption"><p><span class="bold"><strong>(h)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid02.png"><div class="caption"><p><span class="bold"><strong>(i)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid03.png"><div class="caption"><p><span class="bold"><strong>(j)</strong></span></p></div></div></div></td></tr><tr><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid04.png"><div class="caption"><p><span class="bold"><strong>(k)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid05.png"><div class="caption"><p><span class="bold"><strong>(l)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid06.png"><div class="caption"><p><span class="bold"><strong>(m)</strong></span></p></div></div></div></td></tr></tbody></table><table border="1"><colgroup><col></colgroup><tbody><tr><td><p><span class="bold"><strong>(h)</strong></span> and 
          		<span class="bold"><strong>(i)</strong></span> are valid 
          		<code class="varname">POLYGON</code>s, <span class="bold"><strong>(j-m)</strong></span> 
          		cannot be represented as single <code class="varname">POLYGON</code>s, but 
          		<span class="bold"><strong>(j)</strong></span> and <span class="bold"><strong>(m)</strong></span>
          		could be represented as a valid <code class="varname">MULTIPOLYGON</code>.
          		</p></td></tr></tbody></table></div><p>A <code class="varname">MULTIPOLYGON</code> is <span class="emphasis"><em>valid</em></span> 
      if and only if all of its elements are valid and the interiors of no two 
      elements intersect.  The boundaries of any two elements may touch, but 
      only at a finite number of <code class="varname">POINT</code>s.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid07.png"><div class="caption"><p><span class="bold"><strong>(n)</strong></span></p></div></div></div></td><td align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid08.png"><div class="caption"><p><span class="bold"><strong>(o)</strong></span></p></div></div></div></td></tr></tbody></table><table border="1"><colgroup><col></colgroup><tbody><tr><td><p><span class="bold"><strong>(n)</strong></span> and 
          		<span class="bold"><strong>(o)</strong></span> are not valid 
          		<code class="varname">MULTIPOLYGON</code>s.</p></td></tr></tbody></table></div><p>Most of the functions implemented by the GEOS library rely on the
      assumption that your geometries are valid as specified by the OpenGIS
      Simple Feature Specification. To check simplicity or validity of 
      geometries you can use the <a class="link" href="ST_IsSimple.html" title="ST_IsSimple">ST_IsSimple()</a> and 
      <a class="link" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid()</a></p><pre class="programlisting">-- Typically, it doesn't make sense to check
-- for validity on linear features since it will always return TRUE.
-- But in this example, PostGIS extends the definition of the OGC IsValid
-- by returning false if a LinearRing (start and end points are the same) 
-- has less than 2 vertices.
gisdb=# SELECT 
   st_isvalid('LINESTRING(0 0, 1 1)'), 
   st_isvalid('LINESTRING(0 0, 0 0)'); 

 st_isvalid | st_isvalid
------------+--------- 
      t     |     f</pre><p>By default, PostGIS does not apply this validity check on geometry
      input, because testing for validity needs lots of CPU time for complex
      geometries, especially polygons. If you do not trust your data sources,
      you can manually enforce such a check to your tables by adding a check
      constraint:</p><pre class="programlisting">ALTER TABLE mytable 
  ADD CONSTRAINT geometry_valid_check 
    CHECK (isvalid(the_geom));</pre><p>If you encounter any strange error messages such as "GEOS
      Intersection() threw an error!" or "JTS Intersection() threw an error!"
      when calling PostGIS functions with valid input geometries, you likely
      found an error in either PostGIS or one of the libraries it uses, and
      you should contact the PostGIS developers. The same is true if a PostGIS
      function returns an invalid geometry for valid input.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Strictly compliant OGC geometries cannot have Z or M values. The
        <a class="link" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid()</a> function won't consider
        higher dimensioned geometries invalid! Invocations of <a class="link" href="AddGeometryColumn.html" title="AddGeometryColumn">AddGeometryColumn()</a> will add a
        constraint checking geometry dimensions, so it is enough to specify 2
        there.</p></td></tr></table></div></div></div><div class="sect1" title="4.3. Loading GIS Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id419979"></a>4.3. Loading GIS Data</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="ch04.html#id419990">4.3.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420038">4.3.2. Using the Loader</a></span></dt></dl></div><p>Once you have created a spatial table, you are ready to upload GIS
    data to the database. Currently, there are two ways to get data into a
    PostGIS/PostgreSQL database: using formatted SQL statements or using the
    Shape file loader/dumper.</p><div class="sect2" title="4.3.1. Using SQL"><div class="titlepage"><div><div><h3 class="title"><a name="id419990"></a>4.3.1. Using SQL</h3></div></div></div><p>If you can convert your data to a text representation, then using
      formatted SQL might be the easiest way to get your data into PostGIS. As
      with Oracle and other SQL databases, data can be bulk loaded by piping a
      large text file full of SQL "INSERT" statements into the SQL terminal
      monitor.</p><p>A data upload file (<code class="filename">roads.sql</code> for example)
      might look like this:</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Please note that 312 is a fictitious spatial reference system (312) for demonstration only. Please use a non-imaginary 
      	one for your location that matches your geometries.</p></td></tr></table></div><pre class="programlisting">BEGIN; 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 243242)',312),'Jeff Rd'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 244817)',312),'Geordie Rd'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 229814)',312),'Paul St'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 259122)',312),'Graeme Ave'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 228134)',312),'Phil Tce'); 
INSERT INTO roads (road_id, roads_geom, road_name) 
  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 268322)',312),'Dave Cres'); 
COMMIT;</pre><p>The data file can be piped into PostgreSQL very easily using the
      "psql" SQL terminal monitor:</p><pre class="programlisting">psql -d [database] -f roads.sql</pre></div><div class="sect2" title="4.3.2. Using the Loader"><div class="titlepage"><div><div><h3 class="title"><a name="id420038"></a>4.3.2. Using the Loader</h3></div></div></div><p>The <code class="filename">shp2pgsql</code> data loader converts ESRI Shape
      files into SQL suitable for insertion into a PostGIS/PostgreSQL
      database. The loader has several operating modes distinguished by
      command line flags:</p><div class="variablelist"><dl><dt><span class="term">-d</span></dt><dd><p>Drops the database table before creating a new table with
            the data in the Shape file.</p></dd><dt><span class="term">-a</span></dt><dd><p>Appends data from the Shape file into the database table.
            Note that to use this option to load multiple files, the files
            must have the same attributes and same data types.</p></dd><dt><span class="term">-c</span></dt><dd><p>Creates a new table and populates it from the Shape file.
            <span class="emphasis"><em>This is the default mode.</em></span></p></dd><dt><span class="term">-p</span></dt><dd><p>Only produces the table creation SQL code, without adding
            any actual data. This can be used if you need to completely
            separate the table creation and data loading steps.</p></dd><dt><span class="term">-D</span></dt><dd><p>Use the PostgreSQL "dump" format for the output data. This
            can be combined with -a, -c and -d. It is much faster to load than
            the default "insert" SQL format. Use this for very large data
            sets.</p></dd><dt><span class="term">-s &lt;SRID&gt;</span></dt><dd><p>Creates and populates the geometry tables with the specified
            SRID.</p></dd><dt><span class="term">-k</span></dt><dd><p>Keep identifiers' case (column, schema and attributes). Note
            that attributes in Shapefile are all UPPERCASE.</p></dd><dt><span class="term">-i</span></dt><dd><p>Coerce all integers to standard 32-bit integers, do not
            create 64-bit bigints, even if the DBF header signature appears to
            warrant it.</p></dd><dt><span class="term">-I</span></dt><dd><p>Create a GiST index on the geometry column.</p></dd><dt><span class="term">-w</span></dt><dd><p>Output WKT format, for use with older (0.x) versions of
            PostGIS. Note that this will introduce coordinate drifts and will
            drop M values from shapefiles.</p></dd><dt><span class="term">-W &lt;encoding&gt;</span></dt><dd><p>Specify encoding of the input data (dbf file). When used,
            all attributes of the dbf are converted from the specified
            encoding to UTF8. The resulting SQL output will contain a
            <code class="code">SET CLIENT_ENCODING to UTF8</code> command, so that the
            backend will be able to reconvert from UTF8 to whatever encoding
            the database is configured to use internally.</p></dd></dl></div><p>Note that -a, -c, -d and -p are mutually exclusive.</p><p>An example session using the loader to create an input file and
      uploading it might look like this:</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable &gt; roads.sql 
# psql -d roadsdb -f roads.sql</pre><p>A conversion and upload can be done all in one step using UNIX
      pipes:</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect1" title="4.4. Retrieving GIS Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id420244"></a>4.4. Retrieving GIS Data</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="ch04.html#id420255">4.4.1. Using SQL</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420379">4.4.2. Using the Dumper</a></span></dt></dl></div><p>Data can be extracted from the database using either SQL or the
    Shape file loader/dumper. In the section on SQL we will discuss some of
    the operators available to do comparisons and queries on spatial
    tables.</p><div class="sect2" title="4.4.1. Using SQL"><div class="titlepage"><div><div><h3 class="title"><a name="id420255"></a>4.4.1. Using SQL</h3></div></div></div><p>The most straightforward means of pulling data out of the
        database is to use a SQL select query to reduce the number of RECORDS and COLUMNS returned
        and dump the resulting columns
        into a parsable text file:</p><pre class="programlisting">db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads; 

road_id | geom                                    | road_name
--------+-----------------------------------------+----------- 
      1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd 
      2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd 
      3 | LINESTRING(192783 228138,192612 229814) | Paul St 
      4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave
      5 | LINESTRING(190131 224148,190871 228134) | Phil Tce
      6 | LINESTRING(198231 263418,198213 268322) | Dave Cres
      7 | LINESTRING(218421 284121,224123 241231) | Chris Way 
(6 rows)</pre><p>However, there will be times when some kind of restriction is
      necessary to cut down the number of fields returned. In the case of
      attribute-based restrictions, just use the same SQL syntax as normal
      with a non-spatial table. In the case of spatial restrictions, the
      following operators are available/useful:</p><div class="variablelist"><dl><dt><span class="term">&amp;&amp;</span></dt><dd><p>This operator tells whether the bounding box of one geometry
            intersects the bounding box of another.</p></dd><dt><span class="term">~=</span></dt><dd><p>This operators tests whether two geometries are
            geometrically identical. For example, if 'POLYGON((0 0,1 1,1 0,0
            0))' is the same as 'POLYGON((0 0,1 1,1 0,0 0))' (it is).</p></dd><dt><span class="term">=</span></dt><dd><p>This operator is a little more naive, it only tests whether
            the bounding boxes of two geometries are the same.</p></dd></dl></div><p>Next, you can use these operators in queries. Note that when
      specifying geometries and boxes on the SQL command line, you must
      explicitly turn the string representations into geometries by using the
      "GeomFromText()" function. So, for example:</p><pre class="programlisting">SELECT road_id, road_name 
  FROM roads 
  WHERE roads_geom ~= ST_GeomFromText('LINESTRING(191232 243118,191108 243242)');</pre><p>The above query would return the single record from the
      "ROADS_GEOM" table in which the geometry was equal to that value.</p><p>When using the "&amp;&amp;" operator, you can specify either a
      BOX3D as the comparison feature or a GEOMETRY. When you specify a
      GEOMETRY, however, its bounding box will be used for the
      comparison.</p><pre class="programlisting">SELECT road_id, road_name 
FROM roads 
WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))');</pre><p>The above query will use the bounding box of the polygon for
      comparison purposes.</p><p>The most common spatial query will probably be a "frame-based"
      query, used by client software, like data browsers and web mappers, to
      grab a "map frame" worth of data for display. Using a "BOX3D" object for
      the frame, such a query looks like this:</p><pre class="programlisting">SELECT ST_AsText(roads_geom) AS geom 
FROM roads 
WHERE 
  roads_geom &amp;&amp; SetSRID('BOX3D(191232 243117,191232 243119)'::box3d,-1);</pre><p>Note the use of the SRID, to specify the projection of the BOX3D.
      The value -1 is used to indicate no specified SRID.</p></div><div class="sect2" title="4.4.2. Using the Dumper"><div class="titlepage"><div><div><h3 class="title"><a name="id420379"></a>4.4.2. Using the Dumper</h3></div></div></div><p>The <code class="filename">pgsql2shp</code> table dumper connects directly
      to the database and converts a table (possibly defined by a query) into
      a shape file. The basic syntax is:</p><pre class="programlisting">pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;</pre><pre class="programlisting">pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;</pre><p>The commandline options are:</p><div class="variablelist"><dl><dt><span class="term">-f &lt;filename&gt;</span></dt><dd><p>Write the output to a particular filename.</p></dd><dt><span class="term">-h &lt;host&gt;</span></dt><dd><p>The database host to connect to.</p></dd><dt><span class="term">-p &lt;port&gt;</span></dt><dd><p>The port to connect to on the database host.</p></dd><dt><span class="term">-P &lt;password&gt;</span></dt><dd><p>The password to use when connecting to the database.</p></dd><dt><span class="term">-u &lt;user&gt;</span></dt><dd><p>The username to use when connecting to the database.</p></dd><dt><span class="term">-g &lt;geometry column&gt;</span></dt><dd><p>In the case of tables with multiple geometry columns, the
            geometry column to use when writing the shape file.</p></dd><dt><span class="term">-b</span></dt><dd><p>Use a binary cursor. This will make the operation faster,
            but will not work if any NON-geometry attribute in the table lacks
            a cast to text.</p></dd><dt><span class="term">-r</span></dt><dd><p>Raw mode. Do not drop the <code class="varname">gid</code> field, or
            escape column names.</p></dd><dt><span class="term">-d</span></dt><dd><p>For backward compatibility: write a 3-dimensional shape file
            when dumping from old (pre-1.0.0) postgis databases (the default
            is to write a 2-dimensional shape file in that case). Starting
            from postgis-1.0.0+, dimensions are fully encoded.</p></dd></dl></div></div></div><div class="sect1" title="4.5. Building Indexes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id420538"></a>4.5. Building Indexes</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="ch04.html#id420580">4.5.1. GiST Indexes</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420631">4.5.2. Using Indexes</a></span></dt></dl></div><p>Indexes are what make using a spatial database for large data sets
    possible. Without indexing, any search for a feature would require a
    "sequential scan" of every record in the database. Indexing speeds up
    searching by organizing the data into a search tree which can be quickly
    traversed to find a particular record. PostgreSQL supports three kinds of
    indexes by default: B-Tree indexes, R-Tree indexes, and GiST
    indexes.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>B-Trees are used for data which can be sorted along one axis;
        for example, numbers, letters, dates. GIS data cannot be rationally
        sorted along one axis (which is greater, (0,0) or (0,1) or (1,0)?) so
        B-Tree indexing is of no use for us.</p></li><li class="listitem"><p>R-Trees break up data into rectangles, and sub-rectangles, and
        sub-sub rectangles, etc. R-Trees are used by some spatial databases to
        index GIS data, but the PostgreSQL R-Tree implementation is not as
        robust as the GiST implementation.</p></li><li class="listitem"><p>GiST (Generalized Search Trees) indexes break up data into
        "things to one side", "things which overlap", "things which are
        inside" and can be used on a wide range of data-types, including GIS
        data. PostGIS uses an R-Tree index implemented on top of GiST to index
        GIS data.</p></li></ul></div><div class="sect2" title="4.5.1. GiST Indexes"><div class="titlepage"><div><div><h3 class="title"><a name="id420580"></a>4.5.1. GiST Indexes</h3></div></div></div><p>GiST stands for "Generalized Search Tree" and is a generic form of
      indexing. In addition to GIS indexing, GiST is used to speed up searches
      on all kinds of irregular data structures (integer arrays, spectral
      data, etc) which are not amenable to normal B-Tree indexing.</p><p>Once a GIS data table exceeds a few thousand rows, you will want
      to build an index to speed up spatial searches of the data (unless all
      your searches are based on attributes, in which case you'll want to
      build a normal index on the attribute fields).</p><p>The syntax for building a GiST index on a "geometry" column is as
      follows:</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] ); </pre><p>Building a spatial index is a computationally intensive exercise:
      on tables of around 1 million rows, on a 300MHz Solaris machine, we have
      found building a GiST index takes about 1 hour. After building an index,
      it is important to force PostgreSQL to collect table statistics, which
      are used to optimize query plans:</p><pre class="programlisting">VACUUM ANALYZE [table_name] [column_name]; 
-- This is only needed for PostgreSQL 7.4 installations and below 
SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);</pre><p>GiST indexes have two advantages over R-Tree indexes in
      PostgreSQL. Firstly, GiST indexes are "null safe", meaning they can
      index columns which include null values. Secondly, GiST indexes support
      the concept of "lossiness" which is important when dealing with GIS
      objects larger than the PostgreSQL 8K page size. Lossiness allows
      PostgreSQL to store only the "important" part of an object in an index
      -- in the case of GIS objects, just the bounding box. GIS objects larger
      than 8K will cause R-Tree indexes to fail in the process of being
      built.</p></div><div class="sect2" title="4.5.2. Using Indexes"><div class="titlepage"><div><div><h3 class="title"><a name="id420631"></a>4.5.2. Using Indexes</h3></div></div></div><p>Ordinarily, indexes invisibly speed up data access: once the index
      is built, the query planner transparently decides when to use index
      information to speed up a query plan. Unfortunately, the PostgreSQL
      query planner does not optimize the use of GiST indexes well, so
      sometimes searches which should use a spatial index instead default to a
      sequence scan of the whole table.</p><p>If you find your spatial indexes are not being used (or your
      attribute indexes, for that matter) there are a couple things you can
      do:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Firstly, make sure statistics are gathered about the number
          and distributions of values in a table, to provide the query planner
          with better information to make decisions around index usage. For
          PostgreSQL 7.4 installations and below this is done by running
          <span class="command"><strong>update_geometry_stats([table_name, column_name])</strong></span>
          (compute distribution) and <span class="command"><strong>VACUUM ANALYZE [table_name]
          [column_name]</strong></span> (compute number of values). Starting with
          PostgreSQL 8.0 running <span class="command"><strong>VACUUM ANALYZE</strong></span> will do
          both operations. You should regularly vacuum your databases anyways
          -- many PostgreSQL DBAs have <span class="command"><strong>VACUUM</strong></span> run as an
          off-peak cron job on a regular basis.</p></li><li class="listitem"><p>If vacuuming does not work, you can force the planner to use
          the index information by using the <span class="command"><strong>SET
          ENABLE_SEQSCAN=OFF</strong></span> command. You should only use this
          command sparingly, and only on spatially indexed queries: generally
          speaking, the planner knows better than you do about when to use
          normal B-Tree indexes. Once you have run your query, you should
          consider setting <code class="varname">ENABLE_SEQSCAN</code> back on, so that
          other queries will utilize the planner as normal.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>As of version 0.6, it should not be necessary to force the
            planner to use the index with
            <code class="varname">ENABLE_SEQSCAN</code>.</p></td></tr></table></div></li><li class="listitem"><p>If you find the planner wrong about the cost of sequential vs
          index scans try reducing the value of random_page_cost in
          postgresql.conf or using SET random_page_cost=#. Default value for
          the parameter is 4, try setting it to 1 or 2. Decrementing the value
          makes the planner more inclined of using Index scans.</p></li></ul></div></div></div><div class="sect1" title="4.6. Complex Queries"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id420725"></a>4.6. Complex Queries</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="ch04.html#id420739">4.6.1. Taking Advantage of Indexes</a></span></dt><dt><span class="sect2"><a href="ch04.html#id420816">4.6.2. Examples of Spatial SQL</a></span></dt></dl></div><p>The <span class="emphasis"><em>raison d'etre</em></span> of spatial database
    functionality is performing queries inside the database which would
    ordinarily require desktop GIS functionality. Using PostGIS effectively
    requires knowing what spatial functions are available, and ensuring that
    appropriate indexes are in place to provide good performance.</p><div class="sect2" title="4.6.1. Taking Advantage of Indexes"><div class="titlepage"><div><div><h3 class="title"><a name="id420739"></a>4.6.1. Taking Advantage of Indexes</h3></div></div></div><p>When constructing a query it is important to remember that only
      the bounding-box-based operators such as &amp;&amp; can take advantage
      of the GiST spatial index. Functions such as
      <code class="varname">distance()</code> cannot use the index to optimize their
      operation. For example, the following query would be quite slow on a
      large table:</p><pre class="programlisting">SELECT the_geom 
FROM geom_table 
WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)')) &lt; 100</pre><p>This query is selecting all the geometries in geom_table which are
      within 100 units of the point (100000, 200000). It will be slow because
      it is calculating the distance between each point in the table and our
      specified point, ie. one <code class="varname">ST_Distance()</code> calculation
      for each row in the table. We can avoid this by using the &amp;&amp;
      operator to reduce the number of distance calculations required:</p><pre class="programlisting">SELECT the_geom 
FROM geom_table 
WHERE the_geom &amp;&amp; 'BOX3D(90900 190900, 100100 200100)'::box3d 
  AND
ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)')) &lt; 100</pre><p>This query selects the same geometries, but it does it in a more
      efficient way. Assuming there is a GiST index on the_geom, the query
      planner will recognize that it can use the index to reduce the number of
      rows before calculating the result of the <code class="varname">distance()</code>
      function. Notice that the <code class="varname">BOX3D</code> geometry which is
      used in the &amp;&amp; operation is a 200 unit square box centered on
      the original point - this is our "query box". The &amp;&amp; operator
      uses the index to quickly reduce the result set down to only those
      geometries which have bounding boxes that overlap the "query box".
      Assuming that our query box is much smaller than the extents of the
      entire geometry table, this will drastically reduce the number of
      distance calculations that need to be done.</p><div class="note" title="Change in Behavior" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Change in Behavior"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Change in Behavior</th></tr><tr><td align="left" valign="top"><p>As of PostGIS 1.3.0, most of the Geometry Relationship
        Functions, with the notable exceptions of ST_Disjoint and ST_Relate,
        include implicit bounding box overlap operators.</p></td></tr></table></div></div><div class="sect2" title="4.6.2. Examples of Spatial SQL"><div class="titlepage"><div><div><h3 class="title"><a name="id420816"></a>4.6.2. Examples of Spatial SQL</h3></div></div></div><p>The examples in this section will make use of two tables, a table
      of linear roads, and a table of polygonal municipality boundaries. The
      table definitions for the <code class="varname">bc_roads</code> table is:</p><pre class="programlisting">Column      | Type              | Description
------------+-------------------+------------------- 
gid         | integer           | Unique ID 
name        | character varying | Road Name 
the_geom    | geometry          | Location Geometry (Linestring)</pre><p>The table definition for the <code class="varname">bc_municipality</code>
      table is:</p><pre class="programlisting">Column     | Type              | Description
-----------+-------------------+------------------- 
gid        | integer           | Unique ID 
code       | integer           | Unique ID 
name       | character varying | City / Town Name 
the_geom   | geometry          | Location Geometry (Polygon)</pre><div class="qandaset" title="Frequently Asked Questions"><a name="id420852"></a><dl><dt>4.6.2.1. <a href="ch04.html#id420854">What is the total length of all roads, expressed in
            kilometers?</a></dt><dt>4.6.2.2. <a href="ch04.html#id420878">How large is the city of Prince George, in hectares?</a></dt><dt>4.6.2.3. <a href="ch04.html#id420902">What is the largest municipality in the province, by
            area?</a></dt><dt>4.6.2.4. <a href="ch04.html#id420934">What is the length of roads fully contained within each
            municipality?</a></dt><dt>4.6.2.5. <a href="ch04.html#id420974">Create a new table with all the roads within the city of
            Prince George.</a></dt><dt>4.6.2.6. <a href="ch04.html#id421001">What is the length in kilometers of "Douglas St" in
            Victoria?</a></dt><dt>4.6.2.7. <a href="ch04.html#id421022">What is the largest municipality polygon that has a
            hole?</a></dt></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"><col><tbody><tr class="question" title="4.6.2.1."><td align="left" valign="top"><a name="id420854"></a><a name="id420856"></a><p><b>4.6.2.1.</b></p></td><td align="left" valign="top"><p>What is the total length of all roads, expressed in
            kilometers?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>You can answer this question with a very simple piece of
            SQL:</p><pre class="programlisting">SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads; 

km_roads 
------------------
70842.1243039643 
(1 row)</pre></td></tr><tr class="question" title="4.6.2.2."><td align="left" valign="top"><a name="id420878"></a><a name="id420880"></a><p><b>4.6.2.2.</b></p></td><td align="left" valign="top"><p>How large is the city of Prince George, in hectares?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This query combines an attribute condition (on the
            municipality name) with a spatial calculation (of the
            area):</p><pre class="programlisting">SELECT 
  ST_Area(the_geom)/10000 AS hectares 
FROM bc_municipality 
WHERE name = 'PRINCE GEORGE'; 

hectares 
------------------ 
32657.9103824927 
(1 row)</pre></td></tr><tr class="question" title="4.6.2.3."><td align="left" valign="top"><a name="id420902"></a><a name="id420904"></a><p><b>4.6.2.3.</b></p></td><td align="left" valign="top"><p>What is the largest municipality in the province, by
            area?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This query brings a spatial measurement into the query
            condition. There are several ways of approaching this problem, but
            the most efficient is below:</p><pre class="programlisting">SELECT 
  name, 
  ST_Area(the_geom)/10000 AS hectares 
FROM 
  bc_municipality 
ORDER BY hectares DESC 
LIMIT 1;

name           | hectares 
---------------+----------------- 
TUMBLER RIDGE  | 155020.02556131 
(1 row)</pre><p>Note that in order to answer this query we have to calculate
            the area of every polygon. If we were doing this a lot it would
            make sense to add an area column to the table that we could
            separately index for performance. By ordering the results in a
            descending direction, and them using the PostgreSQL "LIMIT"
            command we can easily pick off the largest value without using an
            aggregate function like max().</p></td></tr><tr class="question" title="4.6.2.4."><td align="left" valign="top"><a name="id420934"></a><a name="id420936"></a><p><b>4.6.2.4.</b></p></td><td align="left" valign="top"><p>What is the length of roads fully contained within each
            municipality?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This is an example of a "spatial join", because we are
            bringing together data from two tables (doing a join) but using a
            spatial interaction condition ("contained") as the join condition
            rather than the usual relational approach of joining on a common
            key:</p><pre class="programlisting">SELECT 
  m.name, 
  sum(ST_Length(r.the_geom))/1000 as roads_km 
FROM 
  bc_roads AS r,  
  bc_municipality AS m 
WHERE
  ST_Contains(m.the_geom,r.the_geom) 
GROUP BY m.name 
ORDER BY roads_km; 

name                        | roads_km
----------------------------+------------------ 
SURREY                      | 1539.47553551242 
VANCOUVER                   | 1450.33093486576 
LANGLEY DISTRICT            | 833.793392535662 
BURNABY                     | 773.769091404338 
PRINCE GEORGE               | 694.37554369147 
...</pre><p>This query takes a while, because every road in the table is
            summarized into the final result (about 250K roads for our
            particular example table). For smaller overlays (several thousand
            records on several hundred) the response can be very fast.</p></td></tr><tr class="question" title="4.6.2.5."><td align="left" valign="top"><a name="id420974"></a><a name="id420976"></a><p><b>4.6.2.5.</b></p></td><td align="left" valign="top"><p>Create a new table with all the roads within the city of
            Prince George.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>This is an example of an "overlay", which takes in two
            tables and outputs a new table that consists of spatially clipped
            or cut resultants. Unlike the "spatial join" demonstrated above,
            this query actually creates new geometries. An overlay is like a
            turbo-charged spatial join, and is useful for more exact analysis
            work:</p><pre class="programlisting">CREATE TABLE pg_roads as 
SELECT 
  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,
  ST_Length(r.the_geom) AS rd_orig_length, 
  r.* 
FROM 
  bc_roads AS r, 
  bc_municipality AS m 
WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);</pre></td></tr><tr class="question" title="4.6.2.6."><td align="left" valign="top"><a name="id421001"></a><a name="id421004"></a><p><b>4.6.2.6.</b></p></td><td align="left" valign="top"><p>What is the length in kilometers of "Douglas St" in
            Victoria?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT 
  sum(ST_Length(r.the_geom))/1000 AS kilometers 
FROM 
  bc_roads r, 
  bc_municipality m 
WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA' 
	AND ST_Contains(m.the_geom, r.the_geom) ; 

kilometers 
------------------
4.89151904172838 
(1 row)</pre></td></tr><tr class="question" title="4.6.2.7."><td align="left" valign="top"><a name="id421022"></a><a name="id421025"></a><p><b>4.6.2.7.</b></p></td><td align="left" valign="top"><p>What is the largest municipality polygon that has a
            hole?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT gid, name, ST_Area(the_geom) AS area 
FROM bc_municipality 
WHERE ST_NRings(the_geom) &gt; 1 
ORDER BY area DESC LIMIT 1; 

gid  | name         | area
-----+--------------+------------------ 
12   | SPALLUMCHEEN | 257374619.430216 
(1 row)</pre></td></tr></tbody></table></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Frequently Asked Questions </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. Using PostGIS: Building Applications</td></tr></table></div></body></html>
